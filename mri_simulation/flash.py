# -*- coding: utf-8 -*-
"""flash.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/MRsources/MRzero-Core/blob/main/documentation/playground_mr0/flash.ipynb
"""

import MRzeroCore as mr0
import MRzeroCore
import matplotlib.pyplot as plt
from numpy import pi
import torch
import numpy as np

"""(flash)=
# Create a FLASH Sequence

This Notebook demonstrates a simple Fast Low Angle SHot sequence (FLASH). It is a simple gradient echo sequence with low TR and flip angles typically below 10Â°.

Always prefer to write a function that builds the sequence that takes all variables of interest (often flip angles, TE, TR and/or others) as arguments. This way one can easily build variations of the sequence or optimize the arguments with gradient descent when using pyTorch tensors for all variables.
"""


def build_seq() -> mr0.Sequence:
    seq = mr0.Sequence()

    enc = torch.randperm(64) - 32

    for i in range(64):
        rep = seq.new_rep(2 + 64 + 1)
        rep.pulse.usage = mr0.PulseUsage.EXCIT
        rep.pulse.angle = 7 * pi / 180
        rep.pulse.phase = 0.5 * 137.50776405 * (i ** 2 + i + 2) * pi / 180

        rep.event_time[0] = 2e-3  # Pulse
        rep.event_time[1] = 2e-3  # Rewinder
        rep.event_time[2:-1] = 0.08e-3  # Readout
        rep.event_time[-1] = 2e-3  # Spoiler

        rep.gradm[1, 0] = -33
        rep.gradm[2:-1, 0] = 1
        rep.gradm[-1, 0] = 96 - 31

        # Linear reordered phase encoding
        rep.gradm[1, 1] = i - 32
        # rep.gradm[1, 1] = i // 2 if i % 2 == 0 else -(i + 1) // 2
        # rep.gradm[1, 1] = enc[i]
        rep.gradm[-1, 1] = -rep.gradm[1, 1]

        rep.adc_usage[2:-1] = 1
        rep.adc_phase[2:-1] = pi - rep.pulse.phase

    return seq


# Build the default FLASH and show the kspace
seq = build_seq()
seq.plot_kspace_trajectory()

# Until now, the sequence uses normalized grads: The simulation will adapt them
# to the phantom size. If we want to hardcode a fixed FOV instead, we can do so:
seq.normalized_grads = False
for rep in seq:
    rep.gradm[:] /= 200e-3  # 200 mm FOV

# Load a BrainWeb phantom for simulation

# https://github.com/MRsources/MRzero-Core/raw/main/documentation/examples/subject05.npz

# read numpy file
data_from_phantom = np.load('subject05.npz')

# convert all key from numpy to tensor
data_from_phantom = {k: torch.tensor(v) for k, v in data_from_phantom.items()}

# print("heer")
# phantom = mr0.VoxelGridPhantom(PD=data_from_phantom['PD_map'],
#                      T1=data_from_phantom['T1_map'],
#                      T2=data_from_phantom['T2_map'],
#                      T2dash=data_from_phantom['T2dash_map'],
#                      D=data_from_phantom['D_map'])

from MRzeroCore.phantom.voxel_grid_phantom import generate_B0_B1
B0, B1 = generate_B0_B1(data_from_phantom['PD_map'])
phantom = mr0.VoxelGridPhantom(PD=data_from_phantom['PD_map'],
                               T1=data_from_phantom['T1_map'],
                               T2=data_from_phantom['T2_map'],
                               T2dash=data_from_phantom['T2dash_map'],
                               D=data_from_phantom['D_map'],
                               B0=B0,
                               B1=B1,
                               coil_sens=data_from_phantom['D_map'],
                               size=torch.tensor([0.192, 0.192, 0.192]))


phantom = mr0.VoxelGridPhantom.load("subject05.npz")
phantom = phantom.interpolate(64, 64, 32).slices([16])
# phantom = phantom.slices([16])
# The default fov is loaded from the data, but we can change it:
# phantom.size = torch.tensor([0.15, 0.15, 1])

phantom.plot()
data = phantom.build()


def phantom_motion(time: torch.tensor) -> tuple[torch.tensor, torch.tensor]:
    time /= 0.712  # Sequence duration

    phi = 0.8 * time
    x = -0.03 * time ** 2
    y = 0 * time

    phi = torch.as_tensor(phi)
    cos = torch.cos(phi)
    sin = torch.sin(phi)

    # We can't construct tensors directly as this would remove gradients
    offset = torch.zeros(time.numel(), 3)
    offset[:, 0] = x
    offset[:, 1] = y

    rot = torch.zeros(time.numel(), 3, 3)
    rot[:, 0, 0] = cos
    rot[:, 0, 1] = sin
    rot[:, 1, 0] = -sin
    rot[:, 1, 1] = cos
    rot[:, 2, 2] = 1

    return rot, offset


# data.phantom_motion = phantom_motion

# Simulate the sequence

graph = mr0.compute_graph(seq, data)
signal = mr0.execute_graph(graph, seq, data)
reco = mr0.reco_adjoint(signal, seq.get_kspace())




plt.figure()
plt.subplot(121)
plt.title("Magnitude")
plt.imshow(reco.abs().cpu()[:, :, 0].T.T.T, origin='lower', vmin=0, cmap='gray')
plt.subplot(122)
plt.title("Phase")
plt.imshow(reco.angle().cpu()[:, :, 0].T.T.T, origin='lower', vmin=-np.pi, vmax=np.pi, cmap="twilight")
plt.show()
plt.figure(figsize=(7, 5), dpi=120)
graph.plot()
plt.grid()
plt.show()

def radial_sampling(kspace, num_lines):
    """
    Radially sample the given k-space tensor.

    Args:
        kspace (torch.Tensor): The k-space data as a complex tensor of shape [H, W].
        num_lines (int): The number of radial lines to sample.

    Returns:
        torch.Tensor: The radially sampled k-space tensor.
    """
    # Get the dimensions of the k-space
    H, W = kspace.shape
    center = (H // 2, W // 2)

    # Create an empty mask for sampling
    mask = torch.zeros((H, W), dtype=torch.bool)

    # Generate radial lines
    angles = np.linspace(0, np.pi, num_lines, endpoint=False)
    for angle in angles:
        # Calculate the direction vector for the given angle
        direction = np.array([np.cos(angle), np.sin(angle)])

        # Sample points along the line passing through the center
        for t in np.linspace(-max(H, W) // 2, max(H, W) // 2, max(H, W)):
            x = int(center[0] + t * direction[0])
            y = int(center[1] + t * direction[1])

            # Ensure the coordinates are within bounds
            if 0 <= x < H and 0 <= y < W:
                mask[x, y] = True

    # Apply the mask to the k-space to get the sampled k-space
    sampled_kspace = torch.zeros_like(kspace)
    sampled_kspace[mask] = kspace[mask]

    return sampled_kspace


# def spiral_sampling(kspace, num_points):
#     """
#     Spirally sample the given k-space tensor.
#
#     Args:
#         kspace (torch.Tensor): The k-space data as a complex tensor of shape [H, W].
#         num_points (int): The number of points along the spiral trajectory.
#
#     Returns:
#         torch.Tensor: The spirally sampled k-space tensor.
#     """
#     # Get the dimensions of the k-space
#     H, W = kspace.shape
#     center = (H // 2, W // 2)
#
#     # Create an empty mask for sampling
#     mask = torch.zeros((H, W), dtype=torch.bool)
#
#     # Generate a single continuous spiral trajectory
#     theta_max = 12 * np.pi  # Increase the number of turns for a denser spiral
#     for t in np.linspace(0, theta_max, num_points):
#         r = (t / theta_max) * (min(H, W) // 2)  # Radius grows linearly with t
#         x = int(center[0] + r * np.cos(t))
#         y = int(center[1] + r * np.sin(t))
#
#         # Ensure the coordinates are within bounds
#         if 0 <= x < H and 0 <= y < W:
#             mask[x, y] = True
#
#     # Apply the mask to the k-space to get the sampled k-space
#     sampled_kspace = torch.zeros_like(kspace)
#     sampled_kspace[mask] = kspace[mask]
#
#     return sampled_kspace


def spiral_sampling2(kspace, num_points):
    """
    Spirally sample the given k-space tensor.

    Args:
        kspace (torch.Tensor): The k-space data as a complex tensor of shape [H, W].
        num_points (int): The number of points along the spiral trajectory.

    Returns:
        torch.Tensor: The spirally sampled k-space tensor.
    """
    # Get the dimensions of the k-space
    H, W = kspace.shape
    center = (H // 2, W // 2)

    # Create an empty mask for sampling
    mask = torch.zeros((H, W), dtype=torch.bool)

    # Generate a single continuous spiral trajectory with increasing spacing
    theta_max = 12 * np.pi  # Increase the number of turns for a denser spiral
    a = 2  # Controls the rate at which the gap between turns increases
    for t in np.linspace(0, theta_max, num_points):
        r = a * t  # Radius grows with t, and a controls the gap increase
        x = int(center[0] + r * np.cos(t))
        y = int(center[1] + r * np.sin(t))

        # Ensure the coordinates are within bounds
        if 0 <= x < H and 0 <= y < W:
            mask[x, y] = True

    # Apply the mask to the k-space to get the sampled k-space
    sampled_kspace = torch.zeros_like(kspace)
    sampled_kspace[mask] = kspace[mask]

    return sampled_kspace


def spiral_sampling3(kspace, num_points):
    """
    Spirally sample the given k-space tensor.

    Args:
        kspace (torch.Tensor): The k-space data as a complex tensor of shape [H, W].
        num_points (int): The number of points along the spiral trajectory.

    Returns:
        torch.Tensor: The spirally sampled k-space tensor.
    """
    # Get the dimensions of the k-space
    H, W = kspace.shape
    center = (H // 2, W // 2)

    # Create an empty mask for sampling
    mask = torch.zeros((H, W), dtype=torch.bool)

    # Generate a single continuous spiral trajectory with variable spacing
    theta_max = 12 * np.pi  # Increase the number of turns for a denser spiral
    a = 0.096  # Controls the rate at which the gap between turns increases
    b = 0.01 # Controls the density of points at the center
    for t in np.linspace(0, theta_max, num_points):
        # r = np.exp((a + b * t)) * t  # Radius grows with t, with denser points near the center
        r = np.exp(a * t)  # Radius grows with t, with denser points near the center
        x = int(center[0] + r * np.cos(t))
        y = int(center[1] + r * np.sin(t))

        # Ensure the coordinates are within bounds
        if 0 <= x < H and 0 <= y < W:
            mask[x, y] = True

    # Apply the mask to the k-space to get the sampled k-space
    sampled_kspace = torch.zeros_like(kspace)
    sampled_kspace[mask] = kspace[mask]

    return sampled_kspace

# squise access dim
reco = reco.squeeze(2)
kspace = torch.fft.fft2(reco)

# Optionally, you may want to shift the zero-frequency component to the center
kspace_shifted = torch.fft.fftshift(kspace)


sampled_kspace = spiral_sampling3(kspace_shifted, num_points=5000)

# Plot the sampled k-space
kspace_magnitude = torch.abs(sampled_kspace)
kspace_log_magnitude = torch.log(1 + kspace_magnitude)

plt.figure(figsize=(8, 8))
plt.imshow(kspace_log_magnitude.numpy(), cmap='gray')
plt.title('Radially Sampled K-Space (Log Magnitude)')
plt.axis('off')
plt.show()

# Perform inverse FFT to get the image domain representation
reconstructed_image = torch.fft.ifftshift(sampled_kspace)
reconstructed_image = torch.fft.ifft2(reconstructed_image)

# Calculate magnitude and phase of the reconstructed image
image_magnitude = torch.abs(reconstructed_image)
image_phase = torch.angle(reconstructed_image)

# Plot the magnitude and phase of the reconstructed image
plt.figure(figsize=(12, 6))

plt.subplot(1, 2, 1)
# plt.imshow(image_magnitude.numpy().T,origin='lower', vmin=0)
plt.imshow(image_magnitude.numpy().T.T.T,cmap='gray')
plt.title('Image (Magnitude)')
plt.axis('off')

plt.subplot(1, 2, 2)
# plt.imshow(image_phase.numpy().T,  origin='lower', vmin=-np.pi, vmax=np.pi, cmap="twilight")
plt.imshow(image_phase.numpy().T.T.T,  cmap="gray")
plt.title('Image (Phase)')
plt.axis('off')

plt.show()
